{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Lattice Boltzmann method for solid mechanics LBM for solid mechanics is a novel lattice Boltzmann formulation to solve solid mechanics problems. This initial contribution considers linear elasticity in 2D in the quasi static limit. The static equilibrium solution is obtained through an iterative procedure in pseudo time. For the static displacement solution second order convergence is achieved on 2D domains with arbitrary boundary geometry and both Dirichlet and Neumann boundary conditions. Details on the derivations are found here . Code Our Matlab test code of the LBM formulation on arbitrary 2D domains is available on GitHub . This documentation describes the main concept of each function and explains the input and output arguments.","title":"Home"},{"location":"#lattice-boltzmann-method-for-solid-mechanics","text":"LBM for solid mechanics is a novel lattice Boltzmann formulation to solve solid mechanics problems. This initial contribution considers linear elasticity in 2D in the quasi static limit. The static equilibrium solution is obtained through an iterative procedure in pseudo time. For the static displacement solution second order convergence is achieved on 2D domains with arbitrary boundary geometry and both Dirichlet and Neumann boundary conditions. Details on the derivations are found here .","title":"Lattice Boltzmann method for solid mechanics"},{"location":"#code","text":"Our Matlab test code of the LBM formulation on arbitrary 2D domains is available on GitHub . This documentation describes the main concept of each function and explains the input and output arguments.","title":"Code"},{"location":"publications/","text":"Periodic problems This browser does not support PDFs. Please download the PDF to view it: Download PDF . Boundary conditions This browser does not support PDFs. Please download the PDF to view it: Download PDF .","title":"Publications"},{"location":"publications/#periodic-problems","text":"This browser does not support PDFs. Please download the PDF to view it: Download PDF .","title":"Periodic problems"},{"location":"publications/#boundary-conditions","text":"This browser does not support PDFs. Please download the PDF to view it: Download PDF .","title":"Boundary conditions"},{"location":"code/analyticalSolutionFields/","text":"analyticalSolutionFields analyticalSolutionFields(uAnalyticalSym, normalSym, shear, bulk) Based on the target manufactured solution, compute all required input data and verification sets and output as function handles. All quantities are expressed in physical (or dimensionless) units. Input Arguments levelSetFunction - symbolic expression for geometry definition (using symbolic variables x and y ) normalSym - symbolic function of the normal vector (using symbolic variables x and y ) shear , bulk - shear and bulk modulus of the material definition Output Arguments bodyLoadFunction - function handle for x and y component of the body load uBoundaryFunction - function handle for x and y component of the displacement at the Dirichlet boundary tractionBoundaryFunction - function handle for x and y component of the traction at the Neumann boundary normalFunction - function handle for x and y component of the normal vector uDomainFunction - function handle for x and y component of the displacement solution sigmaDomainFunction - function handle for x and y component of the stress solution in Voigt notation [ sigmaxx, sigmayy, sigmaxy ]","title":"analyticalSolutionFields"},{"location":"code/analyticalSolutionFields/#analyticalsolutionfields","text":"analyticalSolutionFields(uAnalyticalSym, normalSym, shear, bulk) Based on the target manufactured solution, compute all required input data and verification sets and output as function handles. All quantities are expressed in physical (or dimensionless) units. Input Arguments levelSetFunction - symbolic expression for geometry definition (using symbolic variables x and y ) normalSym - symbolic function of the normal vector (using symbolic variables x and y ) shear , bulk - shear and bulk modulus of the material definition Output Arguments bodyLoadFunction - function handle for x and y component of the body load uBoundaryFunction - function handle for x and y component of the displacement at the Dirichlet boundary tractionBoundaryFunction - function handle for x and y component of the traction at the Neumann boundary normalFunction - function handle for x and y component of the normal vector uDomainFunction - function handle for x and y component of the displacement solution sigmaDomainFunction - function handle for x and y component of the stress solution in Voigt notation [ sigmaxx, sigmayy, sigmaxy ]","title":"analyticalSolutionFields"},{"location":"code/gridGeneration/","text":"gridGeneration gridGeneration(boundingBox, levelSetFunction, nx) Adjust the bounding box limits so that the geometry defined by the level set function is containend inside and output min/max coordinates of lattice nodes and number of nodes in each direction. The resulting lattice is the smallest rectangle that contains the geometry + one ghost node layer on each side. However, the user must ensure that the input geometry is fully contained inside the boundingBox ! Input Arguments boundingBox - rectangular simulation domain to be filled with the lattice [ x of left side, x of right side, y of bottom side, y of top side ] levelSetFunction - symbolic expression for geometry definition (using symbolic variables x and y nx - number of lattice nodes along x-direction of bounding box (with potential refinement applied) Output Arguments lattice - [ x of first node on the left, x of last node on the right, number of nodes in x direction; y of first node at the bottom, y of last node on the top, number of nodes in y direction ]","title":"gridGeneration"},{"location":"code/gridGeneration/#gridgeneration","text":"gridGeneration(boundingBox, levelSetFunction, nx) Adjust the bounding box limits so that the geometry defined by the level set function is containend inside and output min/max coordinates of lattice nodes and number of nodes in each direction. The resulting lattice is the smallest rectangle that contains the geometry + one ghost node layer on each side. However, the user must ensure that the input geometry is fully contained inside the boundingBox ! Input Arguments boundingBox - rectangular simulation domain to be filled with the lattice [ x of left side, x of right side, y of bottom side, y of top side ] levelSetFunction - symbolic expression for geometry definition (using symbolic variables x and y nx - number of lattice nodes along x-direction of bounding box (with potential refinement applied) Output Arguments lattice - [ x of first node on the left, x of last node on the right, number of nodes in x direction; y of first node at the bottom, y of last node on the top, number of nodes in y direction ]","title":"gridGeneration"},{"location":"code/implicitGeometryRepresentation/","text":"implicitGeometryRepresentation implicitGeometryRepresentation(levelSetFunction, neumannFunction, lattice) Determines the nodes inside the domain, the nodes next to the boundary and sub-grid wall distances of all links intercepting the boundary using a line search algorithm. For the Neumann boundary portion, the normal vector orientation is also determined. Input Arguments levelSetFunction - symbolic expression for geometry definition (using symbolic variables x and y ) neumannGeometryFunction - symbolic function to define Dirichlet <=0 and Neumann >0 portion of boundary grid - output of gridGeneration() [ x of first node on the left, x of last node on the right, number of nodes in x direction; y of first node at the bottom, y of last node on the top, number of nodes in y direction ] Output Arguments The shape of the output data is also specified using the total number of lattice nodes nNodes , number of domain nodes nDomainNodes and number of lattice velocities nVelocities (the code always assumes the D2Q8 stencil) domainIndices - [ 1,nNodes ] - true/false if node is inside the domain domainPositions - [ 2,nDomainNodes ] - x and y position off all nodes inside the domain streamingIndices - cell array of node indeces of all available domain nodes for each streaming direction dirichletIndices - [ nVelocities,nNodes ] - true if specific link of this node intercepts a Dirichlet boundary neumannIndices - [ nVelocities,nNodes ] - true if specific link of this node intercepts a Neumann boundary wallDistances - [ nVelocities,nNodes ] - sub-grid wall distance [0,1] of each boundary node and link that intercepts the boundary (distance between node and boundary interception point along link, normalized by the link distance) boundaryPosition - [ nVelocities,nNodes,2 ] - x and y position of each boundary intersection point for each link and boundary node normalSym - symbolic function of the normal vector streamingMask - [ nVelocities,nNodes ] - true if neighbor along the given link is inside the domain","title":"implicitGeometryRepresentation"},{"location":"code/implicitGeometryRepresentation/#implicitgeometryrepresentation","text":"implicitGeometryRepresentation(levelSetFunction, neumannFunction, lattice) Determines the nodes inside the domain, the nodes next to the boundary and sub-grid wall distances of all links intercepting the boundary using a line search algorithm. For the Neumann boundary portion, the normal vector orientation is also determined. Input Arguments levelSetFunction - symbolic expression for geometry definition (using symbolic variables x and y ) neumannGeometryFunction - symbolic function to define Dirichlet <=0 and Neumann >0 portion of boundary grid - output of gridGeneration() [ x of first node on the left, x of last node on the right, number of nodes in x direction; y of first node at the bottom, y of last node on the top, number of nodes in y direction ] Output Arguments The shape of the output data is also specified using the total number of lattice nodes nNodes , number of domain nodes nDomainNodes and number of lattice velocities nVelocities (the code always assumes the D2Q8 stencil) domainIndices - [ 1,nNodes ] - true/false if node is inside the domain domainPositions - [ 2,nDomainNodes ] - x and y position off all nodes inside the domain streamingIndices - cell array of node indeces of all available domain nodes for each streaming direction dirichletIndices - [ nVelocities,nNodes ] - true if specific link of this node intercepts a Dirichlet boundary neumannIndices - [ nVelocities,nNodes ] - true if specific link of this node intercepts a Neumann boundary wallDistances - [ nVelocities,nNodes ] - sub-grid wall distance [0,1] of each boundary node and link that intercepts the boundary (distance between node and boundary interception point along link, normalized by the link distance) boundaryPosition - [ nVelocities,nNodes,2 ] - x and y position of each boundary intersection point for each link and boundary node normalSym - symbolic function of the normal vector streamingMask - [ nVelocities,nNodes ] - true if neighbor along the given link is inside the domain","title":"implicitGeometryRepresentation"},{"location":"code/precomputeDirichlet/","text":"precomputeDirichlet precomputeDirichlet(dirichletIndices, uBoundaryFunction, boundaryPositions, wallDistances, theta, tauVector) The pre-processing of the Dirichlet boundary condition involves computing the displacement solution at each boundary interception point of all possible links (see here ). The boundary condition is set up by precomputing the right-hand side source term ( inhomogeneity in code) and the momentMatrix to be applied to the available moments at each boundary node for higher-order corrections. Input Arguments dirichletIndices - [ nVelocities,nNodes ] - true if specific link of this node intercepts a Dirichlet boundary uBoundaryFunction - function handle for x and y component of the displacement at the Dirichlet boundary boundaryPosition - [ nVelocities,nNodes,2 ] - x and y position of each boundary intersection point for each link and boundary node wallDistances - [ nVelocities,nNodes ] - sub-grid wall distance [0,1] of each boundary node and link that intercepts the boundary (distance between node and boundary interception point along link, normalized by the link distance) theta - dimensionless lattice speed (here always set to 1/3) tauVector - vector of all dimensionless relaxation times Output Arguments distributionMatrix - determines the linear combination of all post-collision populations at each boundary node to be used for the boundary formulation; for the Dirichlet formulation this is only the outgoing population momentMatrix - determines the linear combination of moments available at each boundary node to perform higher-order corrections inhomogeneity - source term of the boundary formulation to apply the (inhomogeneous) boundary condition","title":"precomputeDirichlet"},{"location":"code/precomputeDirichlet/#precomputedirichlet","text":"precomputeDirichlet(dirichletIndices, uBoundaryFunction, boundaryPositions, wallDistances, theta, tauVector) The pre-processing of the Dirichlet boundary condition involves computing the displacement solution at each boundary interception point of all possible links (see here ). The boundary condition is set up by precomputing the right-hand side source term ( inhomogeneity in code) and the momentMatrix to be applied to the available moments at each boundary node for higher-order corrections. Input Arguments dirichletIndices - [ nVelocities,nNodes ] - true if specific link of this node intercepts a Dirichlet boundary uBoundaryFunction - function handle for x and y component of the displacement at the Dirichlet boundary boundaryPosition - [ nVelocities,nNodes,2 ] - x and y position of each boundary intersection point for each link and boundary node wallDistances - [ nVelocities,nNodes ] - sub-grid wall distance [0,1] of each boundary node and link that intercepts the boundary (distance between node and boundary interception point along link, normalized by the link distance) theta - dimensionless lattice speed (here always set to 1/3) tauVector - vector of all dimensionless relaxation times Output Arguments distributionMatrix - determines the linear combination of all post-collision populations at each boundary node to be used for the boundary formulation; for the Dirichlet formulation this is only the outgoing population momentMatrix - determines the linear combination of moments available at each boundary node to perform higher-order corrections inhomogeneity - source term of the boundary formulation to apply the (inhomogeneous) boundary condition","title":"precomputeDirichlet"},{"location":"code/precomputeNeumann/","text":"precomputeNeumann precomputeNeumann(neumannIndices, streamingMask, tractionBoundaryFunction, bodyLoadFunction, normalBoundaryFunction, boundaryPositions, wallDistances, theta, tauVector, dx, dt, offsetVector) The pre-processing of the Neumann boundary condition involves computing the traction at each boundary interception point of all possible links (see here ). The boundary condition is set up by precomputing the right-hand side source term ( inhomogeneity in code) and the momentMatrix to be applied to the available moments at each boundary node for higher-order corrections. Additionally, potential neighbor nodes inside the domain are determined to perform a finite difference approximation of required quantities that cannot be locally reconstructed. The neighbor node indices and a moment matrix for the linear combination of moments of the neighbor nodes is output as well. Input Arguments neumannIndices - [ nVelocities,nNodes ] - true if specific link of this node intercepts a Neumann boundary streamingMask - [ nVelocities,nNodes ] - true if neighbor along the given link is inside the domain tractionBoundaryFunction - function handle for x and y component of the traction at the Neumann boundary bodyLoadFunction - function handle for x and y component of the body load normalFunction - function handle for x and y component of the normal vector boundaryPosition - [ nVelocities,nNodes,2 ] - x and y position of each boundary intersection point for each link and boundary node wallDistances - [ nVelocities,nNodes ] - sub-grid wall distance [0,1] of each boundary node and link that intercepts the boundary (distance between node and boundary interception point along link, normalized by the link distance) theta - dimensionless lattice speed (here always set to 1/3) tauVector - vector of all dimensionless relaxation times dx , dt - grid spacing and time step size offsetVector - index offset for each streaming direction Output Arguments distributionMatrix - determines the linear combination of all post-collision populations at each boundary node to be used for the boundary formulation momentMatrix - determines the linear combination of moments available at each boundary node to perform higher-order corrections inhomogeneity - source term of the boundary formulation to apply the (inhomogeneous) boundary condition neighborIndices - boundary neighbor nodes required for the finite difference stencil momentNeighborMatrix - determines the linear combination of moments at the neighbor nodes needed for the finite difference stencil","title":"precomputeNeumann"},{"location":"code/precomputeNeumann/#precomputeneumann","text":"precomputeNeumann(neumannIndices, streamingMask, tractionBoundaryFunction, bodyLoadFunction, normalBoundaryFunction, boundaryPositions, wallDistances, theta, tauVector, dx, dt, offsetVector) The pre-processing of the Neumann boundary condition involves computing the traction at each boundary interception point of all possible links (see here ). The boundary condition is set up by precomputing the right-hand side source term ( inhomogeneity in code) and the momentMatrix to be applied to the available moments at each boundary node for higher-order corrections. Additionally, potential neighbor nodes inside the domain are determined to perform a finite difference approximation of required quantities that cannot be locally reconstructed. The neighbor node indices and a moment matrix for the linear combination of moments of the neighbor nodes is output as well. Input Arguments neumannIndices - [ nVelocities,nNodes ] - true if specific link of this node intercepts a Neumann boundary streamingMask - [ nVelocities,nNodes ] - true if neighbor along the given link is inside the domain tractionBoundaryFunction - function handle for x and y component of the traction at the Neumann boundary bodyLoadFunction - function handle for x and y component of the body load normalFunction - function handle for x and y component of the normal vector boundaryPosition - [ nVelocities,nNodes,2 ] - x and y position of each boundary intersection point for each link and boundary node wallDistances - [ nVelocities,nNodes ] - sub-grid wall distance [0,1] of each boundary node and link that intercepts the boundary (distance between node and boundary interception point along link, normalized by the link distance) theta - dimensionless lattice speed (here always set to 1/3) tauVector - vector of all dimensionless relaxation times dx , dt - grid spacing and time step size offsetVector - index offset for each streaming direction Output Arguments distributionMatrix - determines the linear combination of all post-collision populations at each boundary node to be used for the boundary formulation momentMatrix - determines the linear combination of moments available at each boundary node to perform higher-order corrections inhomogeneity - source term of the boundary formulation to apply the (inhomogeneous) boundary condition neighborIndices - boundary neighbor nodes required for the finite difference stencil momentNeighborMatrix - determines the linear combination of moments at the neighbor nodes needed for the finite difference stencil","title":"precomputeNeumann"},{"location":"code/solve/","text":"solve solve(refinementFactor) Main function calling all pre-processing functions, performing the main iteration loop and post-processing. The input section specifies all discretization parameters and the problem definiton : nxBase - number of lattice nodes placed along x-direction of bounding box (see below) timeStepsBase - number of time steps placed in pseudo time segment refinementFactor - factor for grid and time step refinement according to diffusive scaling ( <1 for refinement); comment out if input argument is to be applied E - Young's modulus nu - Poisson's ratio levelSetFunction - symbolic expression for geometry definition (using symbolic variables x and y neumannGeometryFunction - symbolic function to define Dirichlet <=0 and Neumann >0 portion of boundary boundingBox - rectangular simulation domain to be filled with the lattice [ x of left side, x of right side, y of bottom side, y of top side ] uAnalyticalSim - symbolic expression of target manufactured solution to be used to generate all data for the body load, boundary conditions and error analysis Input Arguments refinementFactor - factor for grid and time step refinement according to diffusive scaling Output Arguments dx - grid spacing as characteristic smallness parameter of the simulation L2ErrorDisp , LinfErrorDisp , L2ErrorStress , LinfErrorStress - L2/Linf error of the displacement/stress solution at the final time step ELattice - Young's modulus in lattice units nu - Poisson's ratio (dimensionless)","title":"solve"},{"location":"code/solve/#solve","text":"solve(refinementFactor) Main function calling all pre-processing functions, performing the main iteration loop and post-processing. The input section specifies all discretization parameters and the problem definiton : nxBase - number of lattice nodes placed along x-direction of bounding box (see below) timeStepsBase - number of time steps placed in pseudo time segment refinementFactor - factor for grid and time step refinement according to diffusive scaling ( <1 for refinement); comment out if input argument is to be applied E - Young's modulus nu - Poisson's ratio levelSetFunction - symbolic expression for geometry definition (using symbolic variables x and y neumannGeometryFunction - symbolic function to define Dirichlet <=0 and Neumann >0 portion of boundary boundingBox - rectangular simulation domain to be filled with the lattice [ x of left side, x of right side, y of bottom side, y of top side ] uAnalyticalSim - symbolic expression of target manufactured solution to be used to generate all data for the body load, boundary conditions and error analysis Input Arguments refinementFactor - factor for grid and time step refinement according to diffusive scaling Output Arguments dx - grid spacing as characteristic smallness parameter of the simulation L2ErrorDisp , LinfErrorDisp , L2ErrorStress , LinfErrorStress - L2/Linf error of the displacement/stress solution at the final time step ELattice - Young's modulus in lattice units nu - Poisson's ratio (dimensionless)","title":"solve"}]}